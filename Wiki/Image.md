# Image

Images designed and developed in Unity's current UI workflow are generally supported. Currently the only image
type supported are Image components that have a fill type of ***Simple***. More will be supported on an on need
basis.

## Conversion Pipeline
Images are converted through the `ImageConversionSystem` where the following components are attached to the
entity generated by the conversion system:

| Component | Description |
|:---------:|:------------|
| Material  | The shader and its properties needed to render a mesh |
| TextureKey | The index of the texture that the entity is associated with (see below for more details) |
| AppliedColor | The current color of the Image |
| Dimensions | The size of the image on the canvas - i.e. the rect |
| DefaultSpriteResolution | The original resolution of the sprite (see below for more details) |
| SpriteData | Information of the sprite containing UVs and padding |
| MeshVertexData | Vertex information required by a mesh |
| TriangleIndexElement | Indices needed to generate the mesh |

## Limitations
Currently only ImageTypes that are `Simple` work. Support for `Sliced` sprites are coming.

## Texture Key
The texture key provides the entity with an index to allow looking up the texture in an internal texture bin.
This bin, known as the `TextureBin` is a scriptable object that stores all unique textures currently present and
lives in the `Assets/Resources` folder.

Moving this out of the `Assets/Resources` folder currently breaks the pipeline because, there is no
scriptable object to load on runtime and one is not created. This ensures that there is a "singleton"
of sorts that you can reference all textures by a key. As more images get converted that have new unique textures, more gets added to the `TextureBin`.

### Pruning the TextureBin
> In short, don't do it - this is a manual operation and I currently don't have a good way of pruning things automatically. This is similar to GC collect and reference counting and I don't think it's a good idea to
reinvent the wheel.

There are currently operations on the TextureBin that you can use to prune and optimize the storage, but this is
a manual operation, so you need to provide the indices that are not in use. Lastly, as things are pruned, you
will also need to update all existing images with the correct key.

## DefaultSpriteResolution
This stores the original resolution of the sprite. Meaning that if you had a 100x100 sprite, but your
Image component is 200x200, we want to store the default resolution so we can reason about the scale
of the displayed texture (in our case 2x). The scale computed is required to adjust the resultant
calculation for any kind of padding our sprite needs from the `SpriteData`. This ensures that there is
no stretching and the representation in Editor time is equivalent to runtime.

### Building the Actual Mesh
The `MeshVertexData Buffer` and `TriangleIndexElement Buffer` contain the core data needed to build a
mesh. Images are effectively quads and the `BuildImageVertexDataSystem` takes care of that for you,
calculating the padding and using the canvas scale, to compute the mesh vertices needed to display.
